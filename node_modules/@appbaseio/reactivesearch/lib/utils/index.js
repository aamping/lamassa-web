'use strict';

exports.__esModule = true;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.shade = shade;
/* eslint-disable */
// flattens a nested array
var flatten = function flatten(arr) {
	return arr.reduce(function (flat, toFlatten) {
		return flat.concat(Array.isArray(toFlatten) ? flatten(toFlatten) : toFlatten);
	}, []);
};

var extractSuggestion = function extractSuggestion(val) {
	switch (typeof val === 'undefined' ? 'undefined' : _typeof(val)) {
		case 'string':
			return val.toLowerCase();
		case 'object':
			if (Array.isArray(val)) {
				return flatten(val);
			}
			return null;

		default:
			return val;
	}
};

var getSuggestions = exports.getSuggestions = function getSuggestions(fields, suggestions, currentValue) {
	var suggestionsList = [];
	var labelsList = [];

	var populateSuggestionsList = function populateSuggestionsList(val) {
		// check if the suggestion includes the current value
		// and not already included in other suggestions
		var isWordMatch = currentValue.trim().split(' ').some(function (term) {
			return val.includes(term);
		});
		if (isWordMatch && !labelsList.includes(val)) {
			var option = {
				label: val,
				value: val
			};
			labelsList = [].concat(labelsList, [val]);
			suggestionsList = [].concat(suggestionsList, [option]);
		}
	};

	suggestions.forEach(function (item) {
		fields.forEach(function (field) {
			var label = item._source[field];
			if (label) {
				var val = extractSuggestion(label);
				if (val) {
					if (Array.isArray(val)) {
						val.forEach(function (suggestion) {
							return populateSuggestionsList(suggestion);
						});
					} else {
						populateSuggestionsList(val);
					}
				}
			}
		});
	});

	return suggestionsList;
};

function shade(color, percent) {
	var f = parseInt(color.slice(1), 16);
	var t = percent < 0 ? 0 : 255;
	var p = percent < 0 ? percent * -1 : percent;
	var R = f >> 16;
	var G = f >> 8 & 0x00ff;
	var B = f & 0x0000ff;

	return '#' + (0x1000000 + (Math.round((t - R) * p) + R) * 0x10000 + (Math.round((t - G) * p) + G) * 0x100 + (Math.round((t - B) * p) + B)).toString(16).slice(1);
}